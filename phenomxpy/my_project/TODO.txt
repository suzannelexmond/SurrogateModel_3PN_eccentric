- test greedy algorithm (differen strategy?)
- integrate chi, rel_anomaly and deltaT in all classes

(06/06/2025):
- Somehow the image folder for EMp nodes don't appear eventough it said the images are saved. 
I tried to alter the emperical nodes code to make it more efficient, but it doesnt work yet
I tried it out by adding a _test function, but it already errors in the normal function I don't think I changed.

(17/06/2025):
- I compared SimInspiralTD to PhenomT (from phenomxpy package) and they work in slightly different units:
==============================================================
Comparison of Gravitational Wave Outputs: SimInspiral vs PhenomT
==============================================================

1. Waveform Polarizations
-------------------------
Both methods produce:
  - h_+(t): plus polarization
  - h_x(t): cross polarization

But with different conventions for units and scaling.

2. SimInspiralTD (LALSimulation)
--------------------------------
- Units: SI (strain)
- Includes:
    ✓ Physical constants (G, c)
    ✓ Source masses (kg)
    ✓ Distance to source (m)
    ✓ Inclination, phase, etc.
- Output is directly:
    h(t) ~ (G^2 / c^4) * (M^5/3 * f(t)^{2/3}) / D_L
    → in physical strain units (~10⁻²¹ for typical BBH)

3. PhenomT (phenomxpy)
-----------------------
- Units: Geometrized (G = c = 1)
- Output is:
    h(t) ~ M / D     (dimensionless, normalized)
    (no physical units applied)
- Needs rescaling to match physical strain:
    h_SI(t) = h_PhenomT(t) × (G * M_total / c^2) / D_L

4. Correct Rescaling to SI Strain
----------------------------------
Given:
  - M_total in kg
  - D_L in meters

Use:
  - scaling_factor = (G * M_total / c^2) / D_L
  - h_scaled = h_PhenomT × scaling_factor

This produces waveforms directly comparable to SimInspiralTD.

==============================================================

Applying this, almost gives you the same kind of waveform, but the phase seems slightly off. 

- Made the waveform independent of mass and distance since they are just scaling factors. Did this by doing h(t)*(D/M), because polarisations are dependent like h(t) ~ (M/D)

NEXT TIME:
- Why is there a slight difference in the phase?
- How do I work with phase and amplitude extraction of the waveforms?




18/06/2025:
- Figured out the structure of the phenom waveform!

PhenomT Parameters — User-facing vs Internal Attribute Names

Physical Meaning           | User-facing attribute (set on PhenomT) | Internal attribute (in phen.pWF.__dict__) | Notes
---------------------------------------------------------------------------------------------------------------
Minimum frequency          | f_min                                  | f_lower                                   | Frequency where waveform starts
Reference phase            | phi_ref                                | phiRef                                    | Initial orbital phase
Inclination angle          | inclination                            | inclination                               | Angle between observer and orbital axis
Total mass                 | passed as argument to compute_polarizations | total_mass                                | Needed for physical scaling of strain
Mass ratio                 | mass_ratio (sometimes set on pWF)     | q                                         | Defined as m2/m1 ≤ 1
Individual masses          | (not always set explicitly)            | mass1, mass2                              | Component masses normalized internally
Spin z-components          | spin_1z, spin_2z                      | s1z, s2z                                  | Dimensionless spin projections
Time step size             | delta_t                               | delta_t or delta_t_sec                     | Step size for time-domain arrays
Eccentricity               | eccentricity                          | eccentricity                              | Orbital eccentricity
Mode                       | mode                                 | mode                                      | Harmonic mode(s), e.g., [2,2]
Reference frequency        | f_ref                                | f_ref or sometimes fref                    | Frequency where phase is referenced
Phase reference (mean anomaly) | phi_ref or mean_anomaly           | mean_anomaly or phiRef                     | Orbital phase reference

Notes:
- Use the user-facing attributes when creating and setting up the PhenomT instance.
- The internal attribute names may differ slightly but represent the same physical quantities.
- total_mass is generally passed only when generating physical strains (e.g., in compute_polarizations).
- mass_ratio and individual masses may be interrelated internally; setting mass_ratio is often enough.


Example:
phen = PhenomT(mode=[2,2], eccentricity = 0.01) # eccenticity needs to be called in the model directly or it doesn't trigger PhenomTE!
phen.spin_1z = 0.0
phen.spin_2z = 0.0
phen.inclination = 0.0
phen.phi_ref = 0.0
phen.f_min = 20.0
phen.delta_t = 1/4096



3. Mass and Distance scaling:
-----------------------------
Mass and distance are handled when computing polarizations:

phen.compute_polarizations(
    inclination=incl,
    phiRef=phi_ref,
    times=times,
    total_mass=total_mass,   # total mass in solar masses
    distance=distance        # distance in Mpc
)

If these are omitted, the strain will remain mass- and distance-independent (geometric units).

4. Typical usage example:
-------------------------
phen = PhenomT(mode=[2,2])
phen.spin_1z = 0.0
phen.spin_2z = 0.0
phen.inclination = 0.0
phen.phi_ref = 0.0
phen.f_min = 20.0
phen.delta_t = 1/4096
phen.eccentricity = 0.01

phen.pWF.q = 1.5
phen.pWF.mass1 = 30.0
phen.pWF.mass2 = 20.0

times = np.linspace(-4000, 0, num=3000)
phen.compute_hlm(times)
phen.compute_polarizations(phen.inclination, phen.phi_ref, times, total_mass=50, distance=500)

5. Inspecting parameters:
-------------------------
You can list all internal waveform parameters using:

print(phen.pWF.__dict__)

---

Note:
pWF = "Phenomenological WaveForm" internal parameter object within PhenomT that holds detailed settings and physical parameters.





30/06/2025:
- I was using a different waveform class, so somehow this didn;t give me the right waveform. 
Instead use the class: from phenomxpy.common import Waveform
parameters = {'mass1': m1, # Solar masses
            'mass2':m2, # Solar masses          
            'distance':distance, # Mpc
            'longAscNodes':long_asc_nodes,
            'spin1x':0., 
            'spin1y':0., 
            'spin1z':S1z,
            'spin2x':0., 
            'spin2y':0., 
            'spin2z':S2z, 
            'f_max':0,
            'delta_t_sec':deltaT,
            'inclination':incl, 
            'phiRef':phi_ref - np.pi/2,  # LAL uses phiRef + pi/2
            'eccentricity':ecc,
            'mean_anomaly':0.,
            'mode_array':[[2,2]]
            }

waveform_arguments={}
waveform_arguments["f_lower"] = f_min_eccTD - 1
waveform_arguments["f_ref"] = f_ref

NOTE! 'phiRef':phi_ref - np.pi/2,  # LAL uses phiRef - pi/2
So EccentricTD uses h(t) = h+ + hx and PhenomT uses h(t)= h+ - hx, so this automatically gives pi/2 difference due to cos and sin difference!

- Don't know why this happens yet, butthe waveforms don't seem to have the same length. They do seem to correspond with waveform_arguments["f_lower"] = f_min_eccTD - 1.
Still need to figure out why...

- There still seems to be a veeery slight phase difference, but that is probably due to different approximations and PN-terms.
Possibility to do: plot both in frequency domain and check what the fuck is going on


04/07/2025:
I FIXED IT :)
How to get identical waveforms in geomteric units:
times = np.linspace(-10000, 0, num=10000)  # times in seconds
    phen = phenomt.PhenomTE(
    mode=[2,2],
    times=times,
    eccentricity=eccmin,                  
    f_ref=f_ref,                   
    f_lower=f_min,
    total_mass=total_mass,  
    distance=distance,
    phiRef=np.pi/2 - phiRef,
    inclination=inclination)

    # phen = phenomt.PhenomTE(mode=[2,2], times=times, eccentricity=eccmin, f_ref=f_min, f_lower=f_ref, phiRef=np.pi/2 - phiRef, inclination=inclination)
    phen.compute_polarizations(times=times)
    geom_freq = HztoMf(phen.pWF.f_lower, total_mass)
    f_ref_ref = MftoHz(geom_freq, total_mass2)
    f_min_ref = f_ref_ref

    phen_ref = phenomt.PhenomTE(
    mode=[2,2],
    times=times,
    eccentricity=eccmin,                 
    f_ref=f_ref_ref,                   
    f_lower=f_min_ref,     
    total_mass=total_mass2,
    distance=distance2,             
    phiRef=np.pi/2 - phiRef,
    inclination=inclination)

    # phen = phenomt.PhenomTE(mode=[2,2], times=times, eccentricity=eccmin, f_ref=f_min, f_lower=f_ref, phiRef=np.pi/2 - phiRef, inclination=inclination)
    phen_ref.compute_polarizations(times=times)



    

22/07/2025:
Below is a full example pipeline showing how to build and implement the surrogate:
1. Define a fixed time grid (used in both training & PE),

import numpy as np

duration = 4.0                # seconds
sampling_frequency = 2048    # Hz
n_samples = int(duration * sampling_frequency)

time = np.linspace(0, duration, n_samples, endpoint=False)

2. Generate training waveforms (with a dummy waveform model),
3. Apply greedy basis construction,
4. Build GPR models at empirical nodes,
5. Save your surrogate,
6. Use it with Bilby for injection & parameter estimation.


Example:

OFFLINE:
import numpy as np
from sklearn.gaussian_process import GaussianProcessRegressor
import pickle

# --- Step 1: Generate training data ---
# Example parameters: masses (just 1D for demo)
training_params = np.linspace(10, 60, 20).reshape(-1, 1)  # 20 training points

# Simulate waveforms: for simplicity, waveform amplitude = sin(param * time)
time_grid = np.linspace(0, 1, 100)  # 100 time samples
training_waveforms = np.array([
    np.sin(param * time_grid) for param in training_params.flatten()
])  # shape (20, 100)

# --- Step 2: Reduced basis via SVD (simple surrogate example) ---
# This finds dominant waveform "modes"
U, S, Vt = np.linalg.svd(training_waveforms, full_matrices=False)
n_basis = 5  # number of basis vectors to keep
basis = Vt[:n_basis]  # shape (5, 100)

# --- Step 3: Choose empirical nodes (just pick indices for demo) ---
empirical_nodes = np.linspace(0, 99, n_basis, dtype=int)  # e.g. [0, 24, 49, 74, 99]

# --- Step 4: Train GPRs for coefficients at empirical nodes ---
gpr_models = []
for i in range(n_basis):
    # Extract waveform values at empirical node i
    y = training_waveforms[:, empirical_nodes[i]]  # shape (20,)
    # Train GPR to predict amplitude at this node from params
    gpr = GaussianProcessRegressor()
    gpr.fit(training_params, y)
    gpr_models.append(gpr)

# --- Step 5: Save surrogate components ---
surrogate = {
    'basis': basis,
    'empirical_nodes': empirical_nodes,
    'gpr_models': gpr_models,
    'time_grid': time_grid,
}

with open('trained_surrogate.pkl', 'wb') as f:
    pickle.dump(surrogate, f)

print("Surrogate trained and saved.")


ONLINE:

import numpy as np
import pickle

# Load surrogate (once)
with open('trained_surrogate.pkl', 'rb') as f:
    surrogate = pickle.load(f)

basis = surrogate['basis']             # (5, 100)
empirical_nodes = surrogate['empirical_nodes']  # [0, 24, 49, 74, 99]
gpr_models = surrogate['gpr_models']   # list of 5 GPRs
time_grid = surrogate['time_grid']     # (100,)

def surrogate_predict(params):
    # params: array-like shape (1, number_of_params) e.g. [[35.0]]
    
    # Predict waveform coefficients (amplitude at empirical nodes)
    coeffs = np.array([gpr.predict([params])[0] for gpr in gpr_models])  # shape (5,)
    
    # Reconstruct full waveform using basis and coefficients
    # basis shape: (5, 100), coeffs shape: (5,)
    waveform = np.dot(coeffs, basis)  # shape (100,)
    
    return time_grid, waveform

# Example call during PE:
params = np.array([35.0])
t, amp = surrogate_predict(params)

print(f"Predicted waveform amplitude shape: {amp.shape}")



30/07/2025:
Surrogate Modeling: Regression in the Online and Offline Phase
--------------------------------------------------

Offline Stage (Training)
------------------------
1. Generate Training Waveforms:
   - Create many full waveforms over a parameter grid (e.g. mass ratio, eccentricity, spin, etc.).
   - For each waveform, extract values only at selected empirical interpolation nodes 
     (e.g., 20–50 specific time steps).

2. Fit Regression Models:
   - For each interpolation node, fit a regression model that maps from parameters (lambda) 
     to waveform values:
     
       f_j(lambda) ≈ h(node_j; lambda),  for j = 1, ..., N_nodes
     
   - Regression models can be:
     - Multivariate polynomials
     - Neural networks
     - Gaussian processes
     - Radial basis functions

Online Stage (Waveform Generation)
----------------------------------
1. Input new parameters (lambda).

2. For each empirical interpolation node:
   - Use the pre-trained regression model f_j(lambda) to predict waveform value at that node.

3. Reconstruct the full waveform:
   - Combine the predicted values with the reduced basis:
     
       h(t; lambda) ≈ sum_i=1^N [ c_i(lambda) * e_i(t) ]

     where:
       - c_i(lambda) are the predicted values at empirical nodes (from regression)
       - e_i(t) are the basis vectors from the reduced basis

4. Output the full waveform (hp, hc or real/imag).



HOW TO CALL THE SURROGATE:
import time
import numpy as np

class DummySurrogate:
    def __init__(self, data_path):
        # Simulate loading heavy data from disk (offline stage)
        print("Loading surrogate data...")
        time.sleep(2)  # pretend it takes 2 seconds to load data
        # Let's say we load basis vectors and regression models here
        self.basis = np.random.rand(10, 1000)  # 10 basis vectors, 1000 time samples
        self.coeffs_data = np.random.rand(10, 5)  # regression coefficients for 5 params
        print("Surrogate loaded!")

    def generate_waveform(self, params):
        # Online stage: evaluate regression models at params to get coefficients
        # For simplicity, use a dot product with params (pretend regression)
        coeffs = np.dot(self.coeffs_data, params)  # shape (10,)

        # Reconstruct waveform from basis vectors weighted by coefficients
        waveform = np.dot(coeffs, self.basis)  # shape (1000,)
        return waveform

# Usage:
params_example = np.array([0.1, 0.2, 0.3, 0.4, 0.5])  # example parameter vector

# Load surrogate once (offline)
surrogate = DummySurrogate('path_to_surrogate_data')

# Generate multiple waveforms (online) quickly
for i in range(3):
    start = time.time()
    wf = surrogate.generate_waveform(params_example)
    print(f"Waveform {i+1} generated in {time.time() - start:.4f} seconds")




07/08/2025:

Summary Table: SEOBNRE vs PhenomTE

+-------------------------+------------------------------+------------------------------+
| Feature                 | SEOBNRE                      | PhenomTE                     |
+-------------------------+------------------------------+------------------------------+
| Model Type & Domain     | Time-domain EOB with adaptive| Frequency-domain phenomenological|
|                        | time stepping (ODE solver)    | model, analytical fits       |
+-------------------------+------------------------------+------------------------------+
| Eccentricity Support   | High (up to ~0.9)              | Moderate (up to ~0.3)        |
+-------------------------+------------------------------+------------------------------+
| Spin Support           | Aligned spins only             | Non-precessing spins only    |
+-------------------------+------------------------------+------------------------------+
| Precession             | No                            | No (built on precessing      |
|                        |                              | PhenomTPHM framework, but no |
|                        |                              | precession in PhenomTE yet)  |
+-------------------------+------------------------------+------------------------------+
| Higher Modes           | Yes (e.g. up to l=4)          | Yes (in PhenomTE_HM)         |
+-------------------------+------------------------------+------------------------------+
| IMR Coverage           | Full IMR                      | Full IMR                     |
+-------------------------+------------------------------+------------------------------+
| Speed (per waveform)   | Slow (seconds to minutes)      | Fast (milliseconds to seconds)|
+-------------------------+------------------------------+------------------------------+
| Parameter Space        | Moderate mass ratios (q < ~5) | Wider mass ratios (q < ~15)  |
+-------------------------+------------------------------+------------------------------+
| Calibration            | Limited NR calibration        | Fitted to SEOBNRE and NR     |
+-------------------------+------------------------------+------------------------------+
| Waveform Representation| Time-domain, adaptive steps   | Frequency-domain with built-in|
|                        | (non-uniform time array)       | inverse FFT and option for    |
|                        |                              | fixed user-defined time array |
+-------------------------+------------------------------+------------------------------+
| Surrogate Suitability  | Requires interpolation to      | Supports fixed time arrays    |
|                        | uniform time grid (no built-in)| out of the box, easier for    |
|                        |                              | surrogate building            |
+-------------------------+------------------------------+------------------------------+
| Implementation         | Custom code, not in LALSuite   | Implemented in LALSuite       |
|                        |                              | (ready for PE pipelines)      |
+-------------------------+------------------------------+------------------------------+

Summary:
- SEOBNRE excels in physics fidelity and high eccentricity but is slow and needs extra steps for surrogate modeling.
- PhenomTE is fast, practical for parameter estimation, and convenient due to built-in time-array control, but limited in spin and eccentricity range.
- Combining both requires careful handling but is promising for future waveform modeling improvements.


FUTURE PROSPECTS:
- build a surrogate that can be run with either phenomte or seobnre, so people can choose either better precission and larger parameter space (seobnre) or a faster waveform.
